// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nodes.proto

/*
	Package nodesproto is a generated protocol buffer package.

	It is generated from these files:
		nodes.proto

	It has these top-level messages:
		GraphHeader
		Node
*/
package nodesproto

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// GraphHeader is the first message written over the wire before transfering graph nodes.
//
// It should be preceded by the magic number "\x00bgr" (4 bytes) and the version number 0x1
// written as a little-endian 4 byte integer. Next, the length of the header message should be
// written in varint encoding, directly followed by the message itself.
type GraphHeader struct {
	// LastID is a last node ID used by ID allocator for this graph. Implementation may reserve some
	// IDs space by setting LastID > max(nodes.ID). If not set, max(nodes.ID) is assumed.
	// Tools that manipulate the graph, but want to preserve IDs of the nodes should allocate IDs
	// starting from LastID+1.
	LastId uint64 `protobuf:"varint,1,opt,name=last_id,json=lastId,proto3" json:"last_id,omitempty"`
	// Root is an optional ID of a global root for this graph. This field is used to preserve
	// compatibility with tools that expect a tree-shaped data.
	// Implementation may also store multiple roots by referencing an Array node, or may store
	// multiple named roots by referencing an Object node.
	// If not set explicitly, implementations that expect a tree should search the graph for
	// unused nodes of type Object or Array and treat them as an array of roots.
	Root uint64 `protobuf:"varint,2,opt,name=root,proto3" json:"root,omitempty"`
	// Metadata is an optional ID for a metadata node for this file. Should reference an Object.
	// If set, implementations that expect a tree should exclude it from the list of roots.
	Metadata uint64 `protobuf:"varint,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *GraphHeader) Reset()                    { *m = GraphHeader{} }
func (m *GraphHeader) String() string            { return proto.CompactTextString(m) }
func (*GraphHeader) ProtoMessage()               {}
func (*GraphHeader) Descriptor() ([]byte, []int) { return fileDescriptorNodes, []int{0} }

func (m *GraphHeader) GetLastId() uint64 {
	if m != nil {
		return m.LastId
	}
	return 0
}

func (m *GraphHeader) GetRoot() uint64 {
	if m != nil {
		return m.Root
	}
	return 0
}

func (m *GraphHeader) GetMetadata() uint64 {
	if m != nil {
		return m.Metadata
	}
	return 0
}

// Node represents any node that can be stored in the graph.
//
// A list of Node messages follows directly after GraphHeader and each such message should be preceded by its length
// written in varint encoding. Nodes in the list should always be sorted by ID (ascending).
// ID of a node can be zero, in this case ID will be assigned automatically as prevNode.ID+1 (starting from 1).
//
// In general there is 3 kinds of nodes: Values, Arrays, Objects.
// If Value oneof field is set, all other fields are ignored, and node is decoded as a value node (leaf).
// If any of Keys or KeysFrom fields are set, the node is an Object (set of key-value pairs).
// Only Keys/KeysFrom and Values fields are considered in this case.
// In other cases a node is an Array, and only Values field is considered.
type Node struct {
	// ID is a unique file-local ID of the node.
	// To implement global IDs, application should write additional data to the graph
	// or keep a mapping from file-local IDs to global ones.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Value is a union for primitive value types.
	// These values are always leaf nodes, they should never store any references to other nodes,
	// or other graph-specific information.
	// It is assumed that encoded Value can be copied to a different Graph without any changes.
	//
	// Types that are valid to be assigned to Value:
	//	*Node_String_
	//	*Node_Int
	//	*Node_Uint
	//	*Node_Float
	//	*Node_Bool
	Value isNode_Value `protobuf_oneof:"value"`
	// Keys is an ordered set of Object keys. Coresponding values are stored in Values field.
	Keys []uint64 `protobuf:"varint,7,rep,packed,name=keys" json:"keys,omitempty"`
	// KeysFrom can refer to a node ID previously seen on wire. In this case, Keys from that node
	// are copied to Keys field of current node. Thus, full list of Keys can be omited.
	KeysFrom uint64 `protobuf:"varint,10,opt,name=keys_from,json=keysFrom,proto3" json:"keys_from,omitempty"`
	// Values stores an ordered list of node IDs. Zero ID represents a null node.
	// For Array node this field represent an array itself, and for Object nodes
	// this field is a set of values that coresponds to keys defined by Keys or KeysFrom.
	Values []uint64 `protobuf:"varint,8,rep,packed,name=values" json:"values,omitempty"`
	// IsObject is a helper field to distinguish between empty arrays and empty objects.
	IsObject bool `protobuf:"varint,9,opt,name=is_object,json=isObject,proto3" json:"is_object,omitempty"`
	// ValuesOffs is an offset added to all value IDs. Used for compression.
	ValuesOffs uint64 `protobuf:"varint,11,opt,name=values_offs,json=valuesOffs,proto3" json:"values_offs,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorNodes, []int{1} }

type isNode_Value interface {
	isNode_Value()
	MarshalTo([]byte) (int, error)
	ProtoSize() int
}

type Node_String_ struct {
	String_ string `protobuf:"bytes,2,opt,name=string,proto3,oneof"`
}
type Node_Int struct {
	Int int64 `protobuf:"varint,3,opt,name=int,proto3,oneof"`
}
type Node_Uint struct {
	Uint uint64 `protobuf:"varint,4,opt,name=uint,proto3,oneof"`
}
type Node_Float struct {
	Float float64 `protobuf:"fixed64,5,opt,name=float,proto3,oneof"`
}
type Node_Bool struct {
	Bool bool `protobuf:"varint,6,opt,name=bool,proto3,oneof"`
}

func (*Node_String_) isNode_Value() {}
func (*Node_Int) isNode_Value()     {}
func (*Node_Uint) isNode_Value()    {}
func (*Node_Float) isNode_Value()   {}
func (*Node_Bool) isNode_Value()    {}

func (m *Node) GetValue() isNode_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Node) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetString_() string {
	if x, ok := m.GetValue().(*Node_String_); ok {
		return x.String_
	}
	return ""
}

func (m *Node) GetInt() int64 {
	if x, ok := m.GetValue().(*Node_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Node) GetUint() uint64 {
	if x, ok := m.GetValue().(*Node_Uint); ok {
		return x.Uint
	}
	return 0
}

func (m *Node) GetFloat() float64 {
	if x, ok := m.GetValue().(*Node_Float); ok {
		return x.Float
	}
	return 0
}

func (m *Node) GetBool() bool {
	if x, ok := m.GetValue().(*Node_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *Node) GetKeys() []uint64 {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Node) GetKeysFrom() uint64 {
	if m != nil {
		return m.KeysFrom
	}
	return 0
}

func (m *Node) GetValues() []uint64 {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *Node) GetIsObject() bool {
	if m != nil {
		return m.IsObject
	}
	return false
}

func (m *Node) GetValuesOffs() uint64 {
	if m != nil {
		return m.ValuesOffs
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Node) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Node_OneofMarshaler, _Node_OneofUnmarshaler, _Node_OneofSizer, []interface{}{
		(*Node_String_)(nil),
		(*Node_Int)(nil),
		(*Node_Uint)(nil),
		(*Node_Float)(nil),
		(*Node_Bool)(nil),
	}
}

func _Node_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Node)
	// value
	switch x := m.Value.(type) {
	case *Node_String_:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.String_)
	case *Node_Int:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int))
	case *Node_Uint:
		_ = b.EncodeVarint(4<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Uint))
	case *Node_Float:
		_ = b.EncodeVarint(5<<3 | proto.WireFixed64)
		_ = b.EncodeFixed64(math.Float64bits(x.Float))
	case *Node_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		_ = b.EncodeVarint(6<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case nil:
	default:
		return fmt.Errorf("Node.Value has unexpected type %T", x)
	}
	return nil
}

func _Node_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Node)
	switch tag {
	case 2: // value.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Node_String_{x}
		return true, err
	case 3: // value.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Node_Int{int64(x)}
		return true, err
	case 4: // value.uint
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Node_Uint{x}
		return true, err
	case 5: // value.float
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Value = &Node_Float{math.Float64frombits(x)}
		return true, err
	case 6: // value.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Node_Bool{x != 0}
		return true, err
	default:
		return false, nil
	}
}

func _Node_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Node)
	// value
	switch x := m.Value.(type) {
	case *Node_String_:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *Node_Int:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *Node_Uint:
		n += proto.SizeVarint(4<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Uint))
	case *Node_Float:
		n += proto.SizeVarint(5<<3 | proto.WireFixed64)
		n += 8
	case *Node_Bool:
		n += proto.SizeVarint(6<<3 | proto.WireVarint)
		n += 1
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*GraphHeader)(nil), "gopkg.in.bblfsh.sdk.v2.uast.nodes.GraphHeader")
	proto.RegisterType((*Node)(nil), "gopkg.in.bblfsh.sdk.v2.uast.nodes.Node")
}
func (m *GraphHeader) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GraphHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNodes(dAtA, i, uint64(m.LastId))
	}
	if m.Root != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintNodes(dAtA, i, uint64(m.Root))
	}
	if m.Metadata != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintNodes(dAtA, i, uint64(m.Metadata))
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNodes(dAtA, i, uint64(m.Id))
	}
	if m.Value != nil {
		nn1, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn1
	}
	if len(m.Keys) > 0 {
		dAtA3 := make([]byte, len(m.Keys)*10)
		var j2 int
		for _, num := range m.Keys {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintNodes(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if len(m.Values) > 0 {
		dAtA5 := make([]byte, len(m.Values)*10)
		var j4 int
		for _, num := range m.Values {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0x42
		i++
		i = encodeVarintNodes(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.IsObject {
		dAtA[i] = 0x48
		i++
		if m.IsObject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.KeysFrom != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNodes(dAtA, i, uint64(m.KeysFrom))
	}
	if m.ValuesOffs != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintNodes(dAtA, i, uint64(m.ValuesOffs))
	}
	return i, nil
}

func (m *Node_String_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x12
	i++
	i = encodeVarintNodes(dAtA, i, uint64(len(m.String_)))
	i += copy(dAtA[i:], m.String_)
	return i, nil
}
func (m *Node_Int) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintNodes(dAtA, i, uint64(m.Int))
	return i, nil
}
func (m *Node_Uint) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x20
	i++
	i = encodeVarintNodes(dAtA, i, uint64(m.Uint))
	return i, nil
}
func (m *Node_Float) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x29
	i++
	binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Float))))
	i += 8
	return i, nil
}
func (m *Node_Bool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x30
	i++
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func encodeVarintNodes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GraphHeader) ProtoSize() (n int) {
	var l int
	_ = l
	if m.LastId != 0 {
		n += 1 + sovNodes(uint64(m.LastId))
	}
	if m.Root != 0 {
		n += 1 + sovNodes(uint64(m.Root))
	}
	if m.Metadata != 0 {
		n += 1 + sovNodes(uint64(m.Metadata))
	}
	return n
}

func (m *Node) ProtoSize() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovNodes(uint64(m.Id))
	}
	if m.Value != nil {
		n += m.Value.ProtoSize()
	}
	if len(m.Keys) > 0 {
		l = 0
		for _, e := range m.Keys {
			l += sovNodes(uint64(e))
		}
		n += 1 + sovNodes(uint64(l)) + l
	}
	if len(m.Values) > 0 {
		l = 0
		for _, e := range m.Values {
			l += sovNodes(uint64(e))
		}
		n += 1 + sovNodes(uint64(l)) + l
	}
	if m.IsObject {
		n += 2
	}
	if m.KeysFrom != 0 {
		n += 1 + sovNodes(uint64(m.KeysFrom))
	}
	if m.ValuesOffs != 0 {
		n += 1 + sovNodes(uint64(m.ValuesOffs))
	}
	return n
}

func (m *Node_String_) ProtoSize() (n int) {
	var l int
	_ = l
	l = len(m.String_)
	n += 1 + l + sovNodes(uint64(l))
	return n
}
func (m *Node_Int) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovNodes(uint64(m.Int))
	return n
}
func (m *Node_Uint) ProtoSize() (n int) {
	var l int
	_ = l
	n += 1 + sovNodes(uint64(m.Uint))
	return n
}
func (m *Node_Float) ProtoSize() (n int) {
	var l int
	_ = l
	n += 9
	return n
}
func (m *Node_Bool) ProtoSize() (n int) {
	var l int
	_ = l
	n += 2
	return n
}

func sovNodes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNodes(x uint64) (n int) {
	return sovNodes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GraphHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNodes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GraphHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GraphHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastId", wireType)
			}
			m.LastId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			m.Root = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Root |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			m.Metadata = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Metadata |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNodes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNodes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNodes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNodes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Node_String_{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Node_Int{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uint", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Node_Uint{v}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Value = &Node_Float{float64(math.Float64frombits(v))}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Node_Bool{b}
		case 7:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNodes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Keys = append(m.Keys, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNodes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNodes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNodes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Keys = append(m.Keys, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNodes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Values = append(m.Values, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNodes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNodes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNodes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Values = append(m.Values, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsObject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsObject = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysFrom", wireType)
			}
			m.KeysFrom = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysFrom |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValuesOffs", wireType)
			}
			m.ValuesOffs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValuesOffs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNodes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNodes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNodes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNodes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNodes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNodes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNodes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNodes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNodes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNodes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("nodes.proto", fileDescriptorNodes) }

var fileDescriptorNodes = []byte{
	// 367 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x3c, 0x91, 0xc1, 0x8e, 0xd3, 0x30,
	0x10, 0x86, 0xe3, 0x36, 0x4d, 0xdb, 0xa9, 0xc4, 0xc1, 0x42, 0x8b, 0xb5, 0xa0, 0x10, 0xf6, 0xd4,
	0x0b, 0x5e, 0x09, 0xde, 0x60, 0x0f, 0x10, 0x2e, 0xac, 0x94, 0x03, 0x07, 0x2e, 0x91, 0xb3, 0xb6,
	0x53, 0xd3, 0x24, 0x53, 0xc5, 0xce, 0x4a, 0xbc, 0x09, 0x47, 0x1e, 0x87, 0x23, 0x8f, 0x80, 0xca,
	0x8b, 0xac, 0x3c, 0x59, 0xf5, 0xe4, 0xf9, 0xfe, 0x99, 0xff, 0xd7, 0x58, 0x03, 0xbb, 0x01, 0xb5,
	0xf1, 0xf2, 0x34, 0x62, 0x40, 0xfe, 0xae, 0xc5, 0xd3, 0xb1, 0x95, 0x6e, 0x90, 0x4d, 0xd3, 0x59,
	0x7f, 0x90, 0x5e, 0x1f, 0xe5, 0xe3, 0x07, 0x39, 0x29, 0x1f, 0x24, 0x0d, 0x5e, 0xbf, 0x6f, 0x5d,
	0x38, 0x4c, 0x8d, 0x7c, 0xc0, 0xfe, 0xb6, 0xc5, 0x16, 0x6f, 0xc9, 0xd9, 0x4c, 0x96, 0x88, 0x80,
	0xaa, 0x39, 0xf1, 0xe6, 0x1b, 0xec, 0x3e, 0x8f, 0xea, 0x74, 0x28, 0x8d, 0xd2, 0x66, 0xe4, 0xaf,
	0x60, 0xdd, 0x29, 0x1f, 0x6a, 0xa7, 0x05, 0x2b, 0xd8, 0x3e, 0xad, 0xb2, 0x88, 0x5f, 0x34, 0xe7,
	0x90, 0x8e, 0x88, 0x41, 0x2c, 0x48, 0xa5, 0x9a, 0x5f, 0xc3, 0xa6, 0x37, 0x41, 0x69, 0x15, 0x94,
	0x58, 0x92, 0x7e, 0xe1, 0x9b, 0x5f, 0x0b, 0x48, 0xbf, 0xa2, 0x36, 0xfc, 0x05, 0x2c, 0x2e, 0x61,
	0x0b, 0xa7, 0xb9, 0x80, 0xcc, 0x87, 0xd1, 0x0d, 0x2d, 0x45, 0x6d, 0xcb, 0xa4, 0x7a, 0x66, 0xce,
	0x61, 0xe9, 0x86, 0x40, 0x49, 0xcb, 0x32, 0xa9, 0x22, 0xf0, 0x97, 0x90, 0x4e, 0x51, 0x4c, 0xa3,
	0xbf, 0x4c, 0x2a, 0x22, 0x7e, 0x05, 0x2b, 0xdb, 0xa1, 0x0a, 0x62, 0x55, 0xb0, 0x3d, 0x2b, 0x93,
	0x6a, 0xc6, 0x38, 0xdd, 0x20, 0x76, 0x22, 0x2b, 0xd8, 0x7e, 0x13, 0xa7, 0x23, 0xc5, 0xd5, 0x8f,
	0xe6, 0xa7, 0x17, 0xeb, 0x62, 0x19, 0x57, 0x8f, 0x35, 0xbf, 0x82, 0xec, 0x51, 0x75, 0x93, 0xf1,
	0x62, 0x43, 0xea, 0x33, 0xf1, 0xd7, 0xb0, 0x75, 0xbe, 0xc6, 0xe6, 0x87, 0x79, 0x08, 0x62, 0x1b,
	0x63, 0xaa, 0x8d, 0xf3, 0xf7, 0xc4, 0xb1, 0x19, 0xcd, 0xb5, 0x1d, 0xb1, 0x17, 0x30, 0x7f, 0x38,
	0x0a, 0x9f, 0x46, 0xec, 0xf9, 0x5b, 0xd8, 0xcd, 0x19, 0x35, 0x5a, 0xeb, 0xc5, 0x8e, 0xda, 0x30,
	0x4b, 0xf7, 0xd6, 0xfa, 0xbb, 0x35, 0xac, 0x88, 0xee, 0xde, 0xfc, 0x39, 0xe7, 0xec, 0xef, 0x39,
	0x67, 0xff, 0xce, 0x79, 0xf2, 0xfb, 0x7f, 0xce, 0xbe, 0x03, 0x9d, 0x6e, 0x3e, 0x54, 0x46, 0xcf,
	0xc7, 0xa7, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd1, 0x97, 0x1c, 0x32, 0xf8, 0x01, 0x00, 0x00,
}
